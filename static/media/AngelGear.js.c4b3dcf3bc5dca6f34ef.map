{:version=>3, :sections=>[{:offset=>{:line=>0, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/dice_table/table.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nmodule BCDice\n  module DiceTable\n    # 表を表すクラス\n    class Table\n      # @param key [String]\n      # @param locale [Symbol]\n      # @return [Table]\n      def self.from_i18n(key, locale)\n        table = I18n.t(key, locale: locale)\n        new(table[:name], table[:type], table[:items])\n      end\n\n      # @param [String] name 表の名前\n      # @param [String] type 項目を選ぶときのダイスロールの方法 '1D6'など\n      # @param [Array<String>] items 表の項目の配列\n      def initialize(name, type, items)\n        @name = name\n        @items = items.freeze\n\n        m = /(\\d+)D(\\d+)/i.match(type)\n        unless m\n          raise ArgumentError, \"Unexpected table type: \#{type}\"\n        end\n\n        @times = m[1].to_i\n        @sides = m[2].to_i\n      end\n\n      # 表を振る\n      # @param [BCDice] bcdice ランダマイザ\n      # @return [String] 結果\n      def roll(bcdice)\n        value = bcdice.roll_sum(@times, @sides)\n        return choice(value)\n      end\n\n      def choice(value)\n        index = value - @times\n        return RollResult.new(@name, value, @items[index])\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "<module:BCDice>", "<module:DiceTable>", "<class:Table>", "from_i18n", "self", "key", "locale", "table", "I18n", "t", "new", "[]", "initialize", "name", "type", "items", "@name", "@items", "freeze", "m", "match", "raise", "ArgumentError", "@times", "1", "to_i", "@sides", "2", "roll", "bcdice", "value", "roll_sum", "choice", "index", "-", "RollResult"], :mappings=>"AAAAA,0CAAAA,gBAAAA;EAAAA;;EAEAA,OAAAC;EAAAA;;IAAAA;;IACEA,OAAAC;IAAAA;;MAAAA;;MAEEA,OAAAC;MAAAA;;QAAAA;;AAAAA;;QAIEC,MAAIC,IAAJD,gBAAAA,qBAAmBE,GAAD,EAAMC,MAAxBH;AAAAA,UAAAA;;;UACEI,QAAQC,UAAIC,GAAAA,CAAGJ,GAAP,EAAY,oBAAA,UAAQC,MAAR,EAARG;UACZN,OAAAC,IAAAM,KAAAA,CAAIH,KAAKI,OAAAA,CAAC,MAADA,CAAT,EAAkBJ,KAAKI,OAAAA,CAAC,MAADA,CAAvB,EAAgCJ,KAAKI,OAAAA,CAAC,OAADA,CAArCD;QAFFP,CAAAA;;AAQAS,QAAAA,0BAAAA,sBAAeC,IAAD,EAAOC,IAAP,EAAaC,KAA3BH;AAAAA,UAAAA;;;UACEI,YAAQH;UACRI,aAASF,KAAKG,QAAAA,CAAAA;UAEdC,IAAI,cAAcC,OAAAA,CAAON,IAAPM;UAClB,KAAA,QAAOD,CAAP,CAAA;YACEf,IAAAiB,OAAAA,CAAMC,mBAAN,EAAsBV,yBAAD,GAAA,CAA0BE,IAA1B,CAArBO;UADF;UAIAE,aAASJ,CAACR,OAAAA,CAACa,CAADb,CAAGc,MAAAA,CAAAA;UACbb,OAAAc,CAAAA,aAASP,CAACR,OAAAA,CAACgB,CAADhB,CAAGc,MAAAA,CAAAA,CAAbC;QAVFd,CAAAA;;AAgBAgB,QAAAA,oBAAAA,gBAASC,MAATD;AAAAA,UAAAA;;;UACEE,QAAQD,MAAME,UAAAA,CAAUR,UAAhB,EAAwBG,UAAlBK;UACd,OAAO3B,IAAA4B,QAAAA,CAAOF,KAAPE;QAFTJ,CAAAA;QAKA1B,OAAA8B,sBAAAA,kBAAWF,KAAXE;AAAAA,UAAAA;;;UACEC,QAAcC,UAANJ,KAAMI,EAAEX,UAAFW;UACd,OAAOC,gBAAUzB,KAAAA,CAAKM,SAAf,EAAsBc,KAAtB,EAA6Bb,UAAMN,OAAAA,CAACsB,KAADtB,CAAzBD;QAFnBsB,CAAAA;MAjCF9B,GAAAA,WAAAA,EAAAA,IAAAA;IAFFD,GAAAA,WAAAA;EADFD,GAAAA,WAAAA;AAFAD;"}}, {:offset=>{:line=>61, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/dice_table/d66_grid_table.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nmodule BCDice\n  module DiceTable\n    # D66を振って6x6マスの表を参照する\n    class D66GridTable\n      # @param key [String]\n      # @param locale [Symbol]\n      # @return [D66GridTable]\n      def self.from_i18n(key, locale)\n        table = I18n.t(key, locale: locale, raise: true)\n        new(table[:name], table[:items])\n      end\n\n      # @param [String] name 表の名前\n      # @param [Array<Array<String>>] items 表の項目の配列\n      def initialize(name, items)\n        @name = name\n        @items = items.freeze\n      end\n\n      # 表を振る\n      # @param randomizer [#roll_once] ランダマイザ\n      # @return [String] 結果\n      def roll(randomizer)\n        dice1 = randomizer.roll_once(6)\n        dice2 = randomizer.roll_once(6)\n        value = dice1 * 10 + dice2\n\n        index1 = dice1 - 1\n        index2 = dice2 - 1\n        return RollResult.new(@name, value, @items[index1][index2])\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "<module:BCDice>", "<module:DiceTable>", "<class:D66GridTable>", "from_i18n", "self", "key", "locale", "table", "I18n", "t", "new", "[]", "initialize", "name", "items", "@name", "@items", "freeze", "roll", "randomizer", "dice1", "roll_once", "6", "dice2", "value", "+", "*", "10", "index1", "-", "1", "index2", "RollResult"], :mappings=>"AAAAA,mDAAAA,gBAAAA;EAAAA;;EAEAA,OAAAC;EAAAA;;IAAAA;;IACEA,OAAAC;IAAAA;;MAAAA;;MAEEA,OAAAC;MAAAA;;QAAAA;;AAAAA;;QAIEC,MAAIC,IAAJD,gBAAAA,qBAAmBE,GAAD,EAAMC,MAAxBH;AAAAA,UAAAA;;;UACEI,QAAQC,UAAIC,GAAAA,CAAGJ,GAAP,EAAY,6BAAA,UAAQC,MAAR,EAAA,SAAuB,IAAvB,EAARG;UACZN,OAAAC,IAAAM,KAAAA,CAAIH,KAAKI,OAAAA,CAAC,MAADA,CAAT,EAAkBJ,KAAKI,OAAAA,CAAC,OAADA,CAAvBD;QAFFP,CAAAA;;AAOAS,QAAAA,0BAAAA,sBAAeC,IAAD,EAAOC,KAArBF;AAAAA,UAAAA;;;UACEG,YAAQF;UACRD,OAAAI,CAAAA,aAASF,KAAKG,QAAAA,CAAAA,CAAdD;QAFFJ,CAAAA;QAQAV,OAAAgB,oBAAAA,gBAASC,UAATD;AAAAA,UAAAA;;;UACEE,QAAQD,UAAUE,WAAAA,CAAWC,CAAXD;UAClBE,QAAQJ,UAAUE,WAAAA,CAAWC,CAAXD;UAClBG,QAAmBC,SAALC,UAANN,KAAMM,EAAEC,EAAFD,CAAKD,EAAEF,KAAFE;UAEnBG,SAAeC,UAANT,KAAMS,EAAEC,CAAFD;UACfE,SAAeF,UAANN,KAAMM,EAAEC,CAAFD;UACf,OAAOG,gBAAUtB,KAAAA,CAAKK,SAAf,EAAsBS,KAAtB,EAA6BR,UAAML,OAAAA,CAACiB,MAADjB,CAAQA,OAAAA,CAACoB,MAADpB,CAAjCD;QAPnBQ,CAAAA;MAnBFhB,GAAAA,WAAAA,EAAAA,IAAAA;IAFFD,GAAAA,WAAAA;EADFD,GAAAA,WAAAA;AAFAD;"}}, {:offset=>{:line=>112, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/arithmetic/node.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nmodule BCDice\n  module Arithmetic\n    module Node\n      class BinaryOp\n        def initialize(lhs, op, rhs)\n          @lhs = lhs\n          @op = op\n          @rhs = rhs\n        end\n\n        def eval(round_type)\n          l = @lhs.eval(round_type)\n          r = @rhs.eval(round_type)\n          l.send(@op, r)\n        end\n\n        # @return [String] メッセージへの出力\n        def output\n          \"\#{@lhs.output}\#{@op}\#{@rhs.output}\"\n        end\n\n        # @return [String] ノードのS式\n        def s_exp\n          \"(\#{op_for_s_exp} \#{@lhs.s_exp} \#{@rhs.s_exp})\"\n        end\n\n        # @return [String] S式で使う演算子の表現\n        def op_for_s_exp\n          @op\n        end\n      end\n\n      # 除算ノードの基底クラス\n      #\n      # 定数 +ROUNDING_METHOD+ で端数処理方法を示す記号\n      # ( +'U'+, +'R'+, +''+ ) を定義すること。\n      # また、除算および端数処理を行う +divide_and_round+ メソッドを実装すること。\n      class DivideBase < BinaryOp\n        # ノードを初期化する\n        # @param [Object] lhs 左のオペランドのノード\n        # @param [Object] rhs 右のオペランドのノード\n        def initialize(lhs, rhs)\n          super(lhs, :/, rhs)\n        end\n\n        def eval(round_type)\n          l = @lhs.eval(round_type)\n          r = @rhs.eval(round_type)\n\n          raise ZeroDivisionError if r == 0\n          divide_and_round(l, r, round_type)\n        end\n\n        # メッセージへの出力を返す\n        #\n        # 通常の結果の末尾に、端数処理方法を示す記号を付加する。\n        #\n        # @return [String]\n        def output\n          \"\#{super}\#{rounding_method}\"\n        end\n\n        private\n\n        # 端数処理方法を示す記号を返す\n        # @return [String]\n        def rounding_method\n          self.class::ROUNDING_METHOD\n        end\n\n        # S式で使う演算子の表現を返す\n        # @return [String]\n        def op_for_s_exp\n          \"\#{@op}\#{rounding_method}\"\n        end\n\n        # 除算および端数処理を行う\n        # @param [Integer] _dividend 被除数\n        # @param [Integer] _divisor 除数（0以外）\n        # @param [Symbol] _round_type ゲームシステムの端数処理設定\n        # @return [Integer]\n        def divide_and_round(_dividend, _divisor, _round_type)\n          raise NotImplementedError\n        end\n      end\n\n      # 除算（端数処理はゲームシステム依存）のノード\n      class DivideWithGameSystemDefault < DivideBase\n        # 端数処理方法を示す記号\n        ROUNDING_METHOD = \"\"\n\n        private\n\n        # 除算および端数処理を行う\n        # @param [Integer] dividend 被除数\n        # @param [Integer] divisor 除数（0以外）\n        # @param [Symbol] round_type ゲームシステムの端数処理設定\n        # @return [Integer]\n        def divide_and_round(dividend, divisor, round_type)\n          case round_type\n          when RoundType::CEIL\n            (dividend.to_f / divisor).ceil\n          when RoundType::ROUND\n            x = dividend.to_f / divisor\n            x.negative? ? -(x.abs.round) : x.round\n          else # RoundType::FLOOR\n            (dividend / divisor).floor\n          end\n        end\n      end\n\n      # 除算（切り上げ）のノード\n      class DivideWithCeil < DivideBase\n        # 端数処理方法を示す記号\n        ROUNDING_METHOD = \"C\"\n\n        private\n\n        # 除算および端数処理を行う\n        # @param [Integer] dividend 被除数\n        # @param [Integer] divisor 除数（0以外）\n        # @param [Symbol] _round_type ゲームシステムの端数処理設定\n        # @return [Integer]\n        def divide_and_round(dividend, divisor, _round_type)\n          (dividend.to_f / divisor).ceil\n        end\n      end\n\n      # 除算（四捨五入）のノード\n      class DivideWithRound < DivideBase\n        # 端数処理方法を示す記号\n        ROUNDING_METHOD = \"R\"\n\n        private\n\n        # 除算および端数処理を行う\n        # @param [Integer] dividend 被除数\n        # @param [Integer] divisor 除数（0以外）\n        # @param [Symbol] _round_type ゲームシステムの端数処理設定\n        # @return [Integer]\n        def divide_and_round(dividend, divisor, _round_type)\n          x = dividend.to_f / divisor\n          x.negative? ? -(x.abs.round) : x.round\n        end\n      end\n\n      # 除算（切り捨て）のノード\n      class DivideWithFloor < DivideBase\n        # 端数処理方法を示す記号\n        ROUNDING_METHOD = \"F\"\n\n        private\n\n        # 除算および端数処理を行う\n        # @param [Integer] dividend 被除数\n        # @param [Integer] divisor 除数（0以外）\n        # @param [Symbol] _round_type ゲームシステムの端数処理設定\n        # @return [Integer]\n        def divide_and_round(dividend, divisor, _round_type)\n          (dividend / divisor).floor\n        end\n      end\n\n      class Negative\n        def initialize(body)\n          @body = body\n        end\n\n        def eval(round_type)\n          -@body.eval(round_type)\n        end\n\n        # @return [String] メッセージへの出力\n        def output\n          \"-\#{@body.output}\"\n        end\n\n        def s_exp\n          \"(- \#{@body.s_exp})\"\n        end\n      end\n\n      # カッコで式をまとめるノード\n      class Parenthesis\n        # @param expr [Object] カッコ内のノード\n        def initialize(expr)\n          @expr = expr\n        end\n\n        # @param round_type [Symbol] 端数処理方法\n        # @return [Integer] 評価結果\n        def eval(round_type)\n          @expr.eval(round_type)\n        end\n\n        # @return [String] メッセージへの出力\n        def output\n          \"(\#{@expr.output})\"\n        end\n\n        # @return [String] S式\n        def s_exp\n          \"(Parenthesis \#{@expr.s_exp})\"\n        end\n      end\n\n      class Number\n        def initialize(value)\n          @value = value\n        end\n\n        def eval(_round_type)\n          @value\n        end\n\n        # @return [String] メッセージへの出力\n        def output\n          @value.to_s\n        end\n\n        alias s_exp output\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "<module:BCDice>", "<module:Arithmetic>", "<module:Node>", "<class:BinaryOp>", "initialize", "lhs", "op", "rhs", "@lhs", "@op", "@rhs", "eval", "round_type", "l", "r", "send", "output", "s_exp", "self", "op_for_s_exp", "<class:DivideBase>", "0", "raise", "ZeroDivisionError", "divide_and_round", "rounding_method", "private", "class::ROUNDING_METHOD", "class", "_dividend", "_divisor", "_round_type", "NotImplementedError", "BinaryOp", "<class:DivideWithGameSystemDefault>", "dividend", "divisor", "RoundType::CEIL", "RoundType", "$ret_or_1", "/", "to_f", "ceil", "RoundType::ROUND", "x", "negative?", "abs", "round", "-@", "floor", "DivideBase", "<class:DivideWithCeil>", "<class:DivideWithRound>", "<class:DivideWithFloor>", "<class:Negative>", "@body", "<class:Parenthesis>", "@expr", "<class:Number>", "@value", "to_s"], :mappings=>"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"}}, {:offset=>{:line=>384, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["racc/parser.rb"], :sourcesContent=>["# Opal port of racc/parser.rb.\n#\n# Original license:\n#\n# frozen_string_literal: false\n#--\n# $originalId: parser.rb,v 1.8 2006/07/06 11:42:07 aamine Exp $\n#\n# Copyright (c) 1999-2006 Minero Aoki\n#\n# This program is free software.\n# You can distribute/modify this program under the same terms of ruby.\n#\n# As a special exception, when this code is copied by Racc\n# into a Racc output file, you may use that output file\n# without restriction.\n#++\n\nmodule Racc\n  class ParseError < StandardError; end\nend\nunless defined?(::ParseError)\n  ParseError = Racc::ParseError\nend\n\n# Racc is a LALR(1) parser generator.\n# It is written in Ruby itself, and generates Ruby programs.\n#\n# == Command-line Reference\n#\n#     racc [-o<var>filename</var>] [--output-file=<var>filename</var>]\n#          [-e<var>rubypath</var>] [--embedded=<var>rubypath</var>]\n#          [-v] [--verbose]\n#          [-O<var>filename</var>] [--log-file=<var>filename</var>]\n#          [-g] [--debug]\n#          [-E] [--embedded]\n#          [-l] [--no-line-convert]\n#          [-c] [--line-convert-all]\n#          [-a] [--no-omit-actions]\n#          [-C] [--check-only]\n#          [-S] [--output-status]\n#          [--version] [--copyright] [--help] <var>grammarfile</var>\n#\n# [+filename+]\n#   Racc grammar file. Any extension is permitted.\n# [-o+outfile+, --output-file=+outfile+]\n#   A filename for output. default is <+filename+>.tab.rb\n# [-O+filename+, --log-file=+filename+]\n#   Place logging output in file +filename+.\n#   Default log file name is <+filename+>.output.\n# [-e+rubypath+, --executable=+rubypath+]\n#   output executable file(mode 755). where +path+ is the Ruby interpreter.\n# [-v, --verbose]\n#   verbose mode. create +filename+.output file, like yacc's y.output file.\n# [-g, --debug]\n#   add debug code to parser class. To display debugging information,\n#   use this '-g' option and set @yydebug true in parser class.\n# [-E, --embedded]\n#   Output parser which doesn't need runtime files (racc/parser.rb).\n# [-C, --check-only]\n#   Check syntax of racc grammar file and quit.\n# [-S, --output-status]\n#   Print messages time to time while compiling.\n# [-l, --no-line-convert]\n#   turns off line number converting.\n# [-c, --line-convert-all]\n#   Convert line number of actions, inner, header and footer.\n# [-a, --no-omit-actions]\n#   Call all actions, even if an action is empty.\n# [--version]\n#   print Racc version and quit.\n# [--copyright]\n#   Print copyright and quit.\n# [--help]\n#   Print usage and quit.\n#\n# == Generating Parser Using Racc\n#\n# To compile Racc grammar file, simply type:\n#\n#   $ racc parse.y\n#\n# This creates Ruby script file \"parse.tab.y\". The -o option can change the output filename.\n#\n# == Writing A Racc Grammar File\n#\n# If you want your own parser, you have to write a grammar file.\n# A grammar file contains the name of your parser class, grammar for the parser,\n# user code, and anything else.\n# When writing a grammar file, yacc's knowledge is helpful.\n# If you have not used yacc before, Racc is not too difficult.\n#\n# Here's an example Racc grammar file.\n#\n#   class Calcparser\n#   rule\n#     target: exp { print val[0] }\n#\n#     exp: exp '+' exp\n#        | exp '*' exp\n#        | '(' exp ')'\n#        | NUMBER\n#   end\n#\n# Racc grammar files resemble yacc files.\n# But (of course), this is Ruby code.\n# yacc's $$ is the 'result', $0, $1... is\n# an array called 'val', and $-1, $-2... is an array called '_values'.\n#\n# See the {Grammar File Reference}[rdoc-ref:lib/racc/rdoc/grammar.en.rdoc] for\n# more information on grammar files.\n#\n# == Parser\n#\n# Then you must prepare the parse entry method. There are two types of\n# parse methods in Racc, Racc::Parser#do_parse and Racc::Parser#yyparse\n#\n# Racc::Parser#do_parse is simple.\n#\n# It's yyparse() of yacc, and Racc::Parser#next_token is yylex().\n# This method must returns an array like [TOKENSYMBOL, ITS_VALUE].\n# EOF is [false, false].\n# (TOKENSYMBOL is a Ruby symbol (taken from String#intern) by default.\n# If you want to change this, see the grammar reference.\n#\n# Racc::Parser#yyparse is little complicated, but useful.\n# It does not use Racc::Parser#next_token, instead it gets tokens from any iterator.\n#\n# For example, <code>yyparse(obj, :scan)</code> causes\n# calling +obj#scan+, and you can return tokens by yielding them from +obj#scan+.\n#\n# == Debugging\n#\n# When debugging, \"-v\" or/and the \"-g\" option is helpful.\n#\n# \"-v\" creates verbose log file (.output).\n# \"-g\" creates a \"Verbose Parser\".\n# Verbose Parser prints the internal status when parsing.\n# But it's _not_ automatic.\n# You must use -g option and set +@yydebug+ to +true+ in order to get output.\n# -g option only creates the verbose parser.\n#\n# === Racc reported syntax error.\n#\n# Isn't there too many \"end\"?\n# grammar of racc file is changed in v0.10.\n#\n# Racc does not use '%' mark, while yacc uses huge number of '%' marks..\n#\n# === Racc reported \"XXXX conflicts\".\n#\n# Try \"racc -v xxxx.y\".\n# It causes producing racc's internal log file, xxxx.output.\n#\n# === Generated parsers does not work correctly\n#\n# Try \"racc -g xxxx.y\".\n# This command let racc generate \"debugging parser\".\n# Then set @yydebug=true in your parser.\n# It produces a working log of your parser.\n#\n# == Re-distributing Racc runtime\n#\n# A parser, which is created by Racc, requires the Racc runtime module;\n# racc/parser.rb.\n#\n# Ruby 1.8.x comes with Racc runtime module,\n# you need NOT distribute Racc runtime files.\n#\n# If you want to include the Racc runtime module with your parser.\n# This can be done by using '-E' option:\n#\n#   $ racc -E -omyparser.rb myparser.y\n#\n# This command creates myparser.rb which `includes' Racc runtime.\n# Only you must do is to distribute your parser file (myparser.rb).\n#\n# Note: parser.rb is LGPL, but your parser is not.\n# Your own parser is completely yours.\nmodule Racc\n\n  unless defined?(Racc_No_Extensions)\n    Racc_No_Extensions = false # :nodoc:\n  end\n\n  class Parser\n\n    Racc_Runtime_Version = '1.4.6'\n    Racc_Runtime_Revision = %w$originalRevision: 1.8 $[1]\n\n    Racc_Runtime_Core_Version_R = '1.4.6'\n    Racc_Runtime_Core_Revision_R = %w$originalRevision: 1.8 $[1]\n    # DISABLED: opal has no racc/cparse\n    # begin\n    #   require 'racc/cparse'\n    # # Racc_Runtime_Core_Version_C  = (defined in extension)\n    #   Racc_Runtime_Core_Revision_C = Racc_Runtime_Core_Id_C.split[2]\n    #   unless new.respond_to?(:_racc_do_parse_c, true)\n    #     raise LoadError, 'old cparse.so'\n    #   end\n    #   if Racc_No_Extensions\n    #     raise LoadError, 'selecting ruby version of racc runtime core'\n    #   end\n    #\n    #   Racc_Main_Parsing_Routine    = :_racc_do_parse_c # :nodoc:\n    #   Racc_YY_Parse_Method         = :_racc_yyparse_c # :nodoc:\n    #   Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_C # :nodoc:\n    #   Racc_Runtime_Core_Revision   = Racc_Runtime_Core_Revision_C # :nodoc:\n    #   Racc_Runtime_Type            = 'c' # :nodoc:\n    # rescue LoadError\n      Racc_Main_Parsing_Routine    = :_racc_do_parse_rb\n      Racc_YY_Parse_Method         = :_racc_yyparse_rb\n      Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_R\n      Racc_Runtime_Core_Revision   = Racc_Runtime_Core_Revision_R\n      Racc_Runtime_Type            = 'ruby'\n    # end\n\n    def Parser.racc_runtime_type # :nodoc:\n      Racc_Runtime_Type\n    end\n\n    def _racc_setup\n      @yydebug = false unless self.class::Racc_debug_parser\n      @yydebug = false unless defined?(@yydebug)\n      if @yydebug\n        @racc_debug_out = $stderr unless defined?(@racc_debug_out)\n        @racc_debug_out ||= $stderr\n      end\n      arg = self.class::Racc_arg\n      arg[13] = true if arg.size < 14\n      arg\n    end\n\n    def _racc_init_sysvars\n      @racc_state  = [0]\n      @racc_tstack = []\n      @racc_vstack = []\n\n      @racc_t = nil\n      @racc_val = nil\n\n      @racc_read_next = true\n\n      @racc_user_yyerror = false\n      @racc_error_status = 0\n    end\n\n    # The entry point of the parser. This method is used with #next_token.\n    # If Racc wants to get token (and its value), calls next_token.\n    #\n    # Example:\n    #     def parse\n    #       @q = [[1,1],\n    #             [2,2],\n    #             [3,3],\n    #             [false, '$']]\n    #       do_parse\n    #     end\n    #\n    #     def next_token\n    #       @q.shift\n    #     end\n    def do_parse\n      __send__(Racc_Main_Parsing_Routine, _racc_setup(), false)\n    end\n\n    # The method to fetch next token.\n    # If you use #do_parse method, you must implement #next_token.\n    #\n    # The format of return value is [TOKEN_SYMBOL, VALUE].\n    # +token-symbol+ is represented by Ruby's symbol by default, e.g. :IDENT\n    # for 'IDENT'.  \";\" (String) for ';'.\n    #\n    # The final symbol (End of file) must be false.\n    def next_token\n      raise NotImplementedError, \"\#{self.class}\\#next_token is not defined\"\n    end\n\n    def _racc_do_parse_rb(arg, in_debug)\n      action_table, action_check, action_default, action_pointer,\n      _,            _,            _,              _,\n      _,            _,            token_table,    _,\n      _,            _,            * = arg\n\n      _racc_init_sysvars\n      tok = act = i = nil\n\n      catch(:racc_end_parse) {\n        while true\n          if i = action_pointer[@racc_state[-1]]\n            if @racc_read_next\n              if @racc_t != 0   # not EOF\n                tok, @racc_val = next_token()\n                unless tok      # EOF\n                  @racc_t = 0\n                else\n                  @racc_t = (token_table[tok] or 1)   # error token\n                end\n                racc_read_token(@racc_t, tok, @racc_val) if @yydebug\n                @racc_read_next = false\n              end\n            end\n            i += @racc_t\n            unless i >= 0 and\n                   act = action_table[i] and\n                   action_check[i] == @racc_state[-1]\n              act = action_default[@racc_state[-1]]\n            end\n          else\n            act = action_default[@racc_state[-1]]\n          end\n          while act = _racc_evalact(act, arg)\n            ;\n          end\n        end\n      }\n    end\n\n    # Another entry point for the parser.\n    # If you use this method, you must implement RECEIVER#METHOD_ID method.\n    #\n    # RECEIVER#METHOD_ID is a method to get next token.\n    # It must 'yield' the token, which format is [TOKEN-SYMBOL, VALUE].\n    def yyparse(recv, mid)\n      __send__(Racc_YY_Parse_Method, recv, mid, _racc_setup(), true)\n    end\n\n    def _racc_yyparse_rb(recv, mid, arg, c_debug)\n      action_table, action_check, action_default, action_pointer,\n      _,             _,            _,              _,\n      _,            _,            token_table,    _,\n      _,            _,            * = arg\n\n      _racc_init_sysvars\n      act = nil\n      i = nil\n\n      catch(:racc_end_parse) {\n        until i = action_pointer[@racc_state[-1]]\n          while act = _racc_evalact(action_default[@racc_state[-1]], arg)\n            ;\n          end\n        end\n        recv.__send__(mid) do |tok, val|\n          unless tok\n            @racc_t = 0\n          else\n            @racc_t = (token_table[tok] or 1)   # error token\n          end\n          @racc_val = val\n          @racc_read_next = false\n\n          i += @racc_t\n          unless i >= 0 and\n                 act = action_table[i] and\n                 action_check[i] == @racc_state[-1]\n            act = action_default[@racc_state[-1]]\n          end\n          while act = _racc_evalact(act, arg)\n            ;\n          end\n\n          while not(i = action_pointer[@racc_state[-1]]) or\n                not @racc_read_next or\n                @racc_t == 0   # $\n            unless i and i += @racc_t and\n                   i >= 0 and\n                   act = action_table[i] and\n                   action_check[i] == @racc_state[-1]\n              act = action_default[@racc_state[-1]]\n            end\n            while act = _racc_evalact(act, arg)\n              ;\n            end\n          end\n        end\n      }\n    end\n\n    ###\n    ### common\n    ###\n\n    def _racc_evalact(act, arg)\n      action_table, action_check, _, action_pointer,\n      _,   _, _, _,\n      _,   _, _, shift_n,  reduce_n,\n      _,   _, * = arg\n\n      if act > 0 and act < shift_n\n        #\n        # shift\n        #\n        if @racc_error_status > 0\n          @racc_error_status -= 1 unless @racc_t == 1   # error token\n        end\n        @racc_vstack.push @racc_val\n        @racc_state.push act\n        @racc_read_next = true\n        if @yydebug\n          @racc_tstack.push @racc_t\n          racc_shift @racc_t, @racc_tstack, @racc_vstack\n        end\n\n      elsif act < 0 and act > -reduce_n\n        #\n        # reduce\n        #\n        code = catch(:racc_jump) {\n          @racc_state.push _racc_do_reduce(arg, act)\n          false\n        }\n        if code\n          case code\n          when 1 # yyerror\n            @racc_user_yyerror = true   # user_yyerror\n            return -reduce_n\n          when 2 # yyaccept\n            return shift_n\n          else\n            raise '[Racc Bug] unknown jump code'\n          end\n        end\n\n      elsif act == shift_n\n        #\n        # accept\n        #\n        racc_accept if @yydebug\n        throw :racc_end_parse, @racc_vstack[0]\n\n      elsif act == -reduce_n\n        #\n        # error\n        #\n        case @racc_error_status\n        when 0\n          unless arg[21]    # user_yyerror\n            on_error @racc_t, @racc_val, @racc_vstack\n          end\n        when 3\n          if @racc_t == 0   # is $\n            throw :racc_end_parse, nil\n          end\n          @racc_read_next = true\n        end\n        @racc_user_yyerror = false\n        @racc_error_status = 3\n        while true\n          if i = action_pointer[@racc_state[-1]]\n            i += 1   # error token\n            if  i >= 0 and\n                (act = action_table[i]) and\n                action_check[i] == @racc_state[-1]\n              break\n            end\n          end\n          throw :racc_end_parse, nil if @racc_state.size <= 1\n          @racc_state.pop\n          @racc_vstack.pop\n          if @yydebug\n            @racc_tstack.pop\n            racc_e_pop @racc_state, @racc_tstack, @racc_vstack\n          end\n        end\n        return act\n\n      else\n        raise \"[Racc Bug] unknown action \#{act.inspect}\"\n      end\n\n      racc_next_state(@racc_state[-1], @racc_state) if @yydebug\n\n      nil\n    end\n\n    def _racc_do_reduce(arg, act)\n      _, _, _, _,\n      goto_table,   goto_check,   goto_default,   goto_pointer,\n      nt_base,      reduce_table, _,    _,\n      _,     use_result,   * = arg\n      state = @racc_state\n      vstack = @racc_vstack\n      tstack = @racc_tstack\n\n      i = act * -3\n      len       = reduce_table[i]\n      reduce_to = reduce_table[i+1]\n      method_id = reduce_table[i+2]\n      void_array = []\n\n      tmp_t = tstack[-len, len] if @yydebug\n      tmp_v = vstack[-len, len]\n      tstack[-len, len] = void_array if @yydebug\n      vstack[-len, len] = void_array\n      state[-len, len]  = void_array\n\n      # tstack must be updated AFTER method call\n      if use_result\n        vstack.push __send__(method_id, tmp_v, vstack, tmp_v[0])\n      else\n        vstack.push __send__(method_id, tmp_v, vstack)\n      end\n      tstack.push reduce_to\n\n      racc_reduce(tmp_t, reduce_to, tstack, vstack) if @yydebug\n\n      k1 = reduce_to - nt_base\n      if i = goto_pointer[k1]\n        i += state[-1]\n        if i >= 0 and (curstate = goto_table[i]) and goto_check[i] == k1\n          return curstate\n        end\n      end\n      goto_default[k1]\n    end\n\n    # This method is called when a parse error is found.\n    #\n    # ERROR_TOKEN_ID is an internal ID of token which caused error.\n    # You can get string representation of this ID by calling\n    # #token_to_str.\n    #\n    # ERROR_VALUE is a value of error token.\n    #\n    # value_stack is a stack of symbol values.\n    # DO NOT MODIFY this object.\n    #\n    # This method raises ParseError by default.\n    #\n    # If this method returns, parsers enter \"error recovering mode\".\n    def on_error(t, val, vstack)\n      raise ParseError, sprintf(\"\\nparse error on value %s (%s)\",\n                                val.inspect, token_to_str(t) || '?')\n    end\n\n    # Enter error recovering mode.\n    # This method does not call #on_error.\n    def yyerror\n      throw :racc_jump, 1\n    end\n\n    # Exit parser.\n    # Return value is Symbol_Value_Stack[0].\n    def yyaccept\n      throw :racc_jump, 2\n    end\n\n    # Leave error recovering mode.\n    def yyerrok\n      @racc_error_status = 0\n    end\n\n    # For debugging output\n    def racc_read_token(t, tok, val)\n      @racc_debug_out.print 'read    '\n      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '\n      @racc_debug_out.puts val.inspect\n      @racc_debug_out.puts\n    end\n\n    def racc_shift(tok, tstack, vstack)\n      @racc_debug_out.puts \"shift   \#{racc_token2str tok}\"\n      racc_print_stacks tstack, vstack\n      @racc_debug_out.puts\n    end\n\n    def racc_reduce(toks, sim, tstack, vstack)\n      out = @racc_debug_out\n      out.print 'reduce '\n      if toks.empty?\n        out.print ' <none>'\n      else\n        toks.each {|t| out.print ' ', racc_token2str(t) }\n      end\n      out.puts \" --> \#{racc_token2str(sim)}\"\n\n      racc_print_stacks tstack, vstack\n      @racc_debug_out.puts\n    end\n\n    def racc_accept\n      @racc_debug_out.puts 'accept'\n      @racc_debug_out.puts\n    end\n\n    def racc_e_pop(state, tstack, vstack)\n      @racc_debug_out.puts 'error recovering mode: pop token'\n      racc_print_states state\n      racc_print_stacks tstack, vstack\n      @racc_debug_out.puts\n    end\n\n    def racc_next_state(curstate, state)\n      @racc_debug_out.puts  \"goto    \#{curstate}\"\n      racc_print_states state\n      @racc_debug_out.puts\n    end\n\n    def racc_print_stacks(t, v)\n      out = @racc_debug_out\n      out.print '        ['\n      t.each_index do |i|\n        out.print ' (', racc_token2str(t[i]), ' ', v[i].inspect, ')'\n      end\n      out.puts ' ]'\n    end\n\n    def racc_print_states(s)\n      out = @racc_debug_out\n      out.print '        ['\n      s.each {|st| out.print ' ', st }\n      out.puts ' ]'\n    end\n\n    def racc_token2str(tok)\n      self.class::Racc_token_to_s_table[tok] or\n          raise \"[Racc Bug] can't convert token \#{tok} to string\"\n    end\n\n    # Convert internal ID of token symbol to the string.\n    def token_to_str(t)\n      self.class::Racc_token_to_s_table[t]\n    end\n\n  end\n\nend\n"], :names=>["<top (required)>", "<module:Racc>", "<class:ParseError>", "StandardError", "Racc::ParseError", "Racc", "<class:Parser>", "[]", "1", "Racc_Runtime_Core_Version_R", "Racc_Runtime_Core_Revision_R", "racc_runtime_type", "Parser", "Racc_Runtime_Type", "_racc_setup", "class::Racc_debug_parser", "self", "class", "@yydebug", "@racc_debug_out", "$stderr", "$ret_or_1", "arg", "class::Racc_arg", "<", "size", "14", "[]=", "13", "_racc_init_sysvars", "@racc_state", "0", "@racc_tstack", "@racc_vstack", "@racc_t", "@racc_val", "@racc_read_next", "@racc_user_yyerror", "@racc_error_status", "do_parse", "__send__", "Racc_Main_Parsing_Routine", "next_token", "raise", "NotImplementedError", "_racc_do_parse_rb", "in_debug", "action_table", "action_check", "action_default", "action_pointer", "_", "token_table", "tok", "act", "i", "catch", "block in _racc_do_parse_rb", "block (2 levels) in _racc_do_parse_rb", "-1", "racc_read_token", "+", ">=", "_racc_evalact", "yyparse", "recv", "mid", "Racc_YY_Parse_Method", "_racc_yyparse_rb", "c_debug", "block in _racc_yyparse_rb", "block (2 levels) in _racc_yyparse_rb", "val", "block (3 levels) in _racc_yyparse_rb", "$ret_or_2", "!", "==", "shift_n", "reduce_n", ">", "-", "push", "racc_shift", "-@", "code", "block in _racc_evalact", "block (2 levels) in _racc_evalact", "_racc_do_reduce", "2", "racc_accept", "throw", "21", "on_error", "3", "<=", "pop", "racc_e_pop", "inspect", "racc_next_state", "goto_table", "goto_check", "goto_default", "goto_pointer", "nt_base", "reduce_table", "use_result", "state", "vstack", "tstack", "*", "-3", "len", "reduce_to", "method_id", "void_array", "tmp_t", "tmp_v", "racc_reduce", "k1", "curstate", "t", "ParseError", "sprintf", "token_to_str", "yyerror", "yyaccept", "yyerrok", "print", "racc_token2str", "puts", "racc_print_stacks", "toks", "sim", "out", "empty?", "each", "block in racc_reduce", "block (2 levels) in racc_reduce", "racc_print_states", "v", "each_index", "block in racc_print_stacks", "block (2 levels) in racc_print_stacks", "s", "block in racc_print_states", "st", "block (2 levels) in racc_print_states", "class::Racc_token_to_s_table"], :mappings=>"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"}}, {:offset=>{:line=>852, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["./strscan.rb"], :sourcesContent=>["class StringScanner\n  attr_reader :pos, :matched\n\n  def initialize(string)\n    @string  = string\n    @pos     = 0\n    @matched = nil\n    @working = string\n    @match   = []\n  end\n\n  attr_reader :string\n\n  def beginning_of_line?\n    `\#{@pos} === 0 || \#{@string}.charAt(\#{@pos} - 1) === \"\\n\"`\n  end\n\n  def scan(pattern)\n    pattern = anchor(pattern)\n\n    %x{\n      var result = pattern.exec(\#{@working});\n\n      if (result == null) {\n        return \#{@matched} = nil;\n      }\n      \#{@prev_pos} = \#{@pos};\n      \#{@pos}     += result[0].length;\n      \#{@working}  = \#{@working}.substring(result[0].length);\n      \#{@matched}  = result[0];\n      \#{@match}    = result;\n\n      return result[0];\n    }\n  end\n\n  def scan_until(pattern)\n    pattern = anchor(pattern)\n\n    %x{\n      var working = \#{@working}\n\n      for(var i = 0; working.length != i; ++i) {\n        var result  = pattern.exec(working.substr(i));\n        if (result !== null) {\n          var matched_size = i + result[0].length\n          var matched = working.substr(0, matched_size)\n\n          \#{@matched}  = result[0]\n          \#{@match}  = result\n          \#{@prev_pos} = \#{@pos} + i; // Position of first character of matched\n          \#{@pos} += matched_size // Position one after last character of matched\n          \#{@working} = working.substr(matched_size)\n\n          return matched\n        }\n      }\n      return \#{@matched} = nil;\n    }\n  end\n\n  def [](idx)\n    if @match.empty?\n      return nil\n    end\n    case idx\n    when Symbol\n      idx = idx.to_s\n    when String\n      # noop\n    else\n      idx = ::Opal.coerce_to!(idx, Integer, :to_int)\n    end\n    %x{\n      var match = \#{@match};\n\n      if (idx < 0) {\n        idx += match.length;\n      }\n\n      if (idx < 0 || idx >= match.length) {\n        return nil;\n      }\n\n      if (match[idx] == null) {\n        return nil;\n      }\n\n      return match[idx];\n    }\n  end\n\n  def check(pattern)\n    pattern = anchor(pattern)\n\n    %x{\n      var result = pattern.exec(\#{@working});\n\n      if (result == null) {\n        return \#{@matched} = nil;\n      }\n\n      return \#{@matched} = result[0];\n    }\n  end\n\n  def check_until(pattern)\n    %x{\n      var old_prev_pos = \#{@prev_pos};\n      var old_pos      = \#{@pos};\n      var old_working  = \#{@working};\n\n      var result = \#{scan_until(pattern)};\n\n      \#{@prev_pos} = old_prev_pos;\n      \#{@pos}      = old_pos;\n      \#{@working}  = old_working;\n\n      return result;\n    }\n  end\n\n  def peek(length)\n    `\#{@working}.substring(0, length)`\n  end\n\n  def eos?\n    `\#{@working}.length === 0`\n  end\n\n  def exist?(pattern)\n    %x{\n      var result = pattern.exec(\#{@working});\n\n      if (result == null) {\n        return nil;\n      }\n      else if (result.index == 0) {\n        return 0;\n      }\n      else {\n        return result.index + 1;\n      }\n    }\n  end\n\n  def skip(pattern)\n    pattern = anchor(pattern)\n\n    %x{\n      var result = pattern.exec(\#{@working});\n\n      if (result == null) {\n        \#{@match} = [];\n        return \#{@matched} = nil;\n      }\n      else {\n        var match_str = result[0];\n        var match_len = match_str.length;\n\n        \#{@matched}   = match_str;\n        \#{@match}     = result;\n        \#{@prev_pos}  = \#{@pos};\n        \#{@pos}      += match_len;\n        \#{@working}   = \#{@working}.substring(match_len);\n\n        return match_len;\n      }\n    }\n  end\n\n  def skip_until(pattern)\n    %x{\n      var result = \#{scan_until(pattern)};\n\n      if (result === nil) {\n        return nil;\n      }\n      else {\n        \#{@matched} = result.substr(-1);\n\n        return result.length;\n      }\n    }\n  end\n\n  def get_byte\n    %x{\n      var result = nil;\n\n      if (\#{@pos} < \#{@string}.length) {\n        \#{@prev_pos}  = \#{@pos};\n        \#{@pos}      += 1;\n        result      = \#{@matched} = \#{@working}.substring(0, 1);\n        \#{@working}   = \#{@working}.substring(1);\n      }\n      else {\n        \#{@matched} = nil;\n      }\n\n      return result;\n    }\n  end\n\n  def match?(pattern)\n    pattern = anchor(pattern)\n\n    %x{\n      var result = pattern.exec(\#{@working});\n\n      if (result == null) {\n        return nil;\n      }\n      else {\n        \#{@prev_pos} = \#{@pos};\n\n        return result[0].length;\n      }\n    }\n  end\n\n  def pos=(pos)\n    %x{\n      if (pos < 0) {\n        pos += \#{@string.length};\n      }\n    }\n\n    @pos     = pos\n    @working = `\#{@string}.slice(pos)`\n  end\n\n  def matched_size\n    %x{\n      if (\#{@matched} === nil) {\n        return nil;\n      }\n\n      return \#{@matched}.length\n    }\n  end\n\n  def post_match\n    %x{\n      if (\#{@matched} === nil) {\n        return nil;\n      }\n\n      return \#{@string}.substr(\#{@pos});\n    }\n  end\n\n  def pre_match\n    %x{\n      if (\#{@matched} === nil) {\n        return nil;\n      }\n\n      return \#{@string}.substr(0, \#{@prev_pos});\n    }\n  end\n\n  def reset\n    @working = @string\n    @matched = nil\n    @pos     = 0\n  end\n\n  def rest\n    @working\n  end\n\n  def rest?\n    `\#{@working}.length !== 0`\n  end\n\n  def rest_size\n    rest.size\n  end\n\n  def terminate\n    @match = nil\n    self.pos = @string.length\n  end\n\n  def unscan\n    @pos      = @prev_pos\n    @prev_pos = nil\n    @match    = nil\n\n    self\n  end\n\n  alias bol? beginning_of_line?\n  alias getch get_byte # not exactly the same, but for now...\n\n  private\n\n  def anchor(pattern)\n    %x{\n      var flags = pattern.toString().match(/\\/([^\\/]+)$/);\n      flags = flags ? flags[1] : undefined;\n      return new RegExp('^(?:' + pattern.source + ')', flags);\n    }\n  end\nend\n"], :names=>["<top (required)>", "<class:StringScanner>", "self", "attr_reader", "initialize", "string", "@string", "@pos", "0", "@matched", "@working", "@match", "beginning_of_line?", "scan", "pattern", "anchor", "@prev_pos", "scan_until", "[]", "idx", "empty?", "Symbol", "$ret_or_1", "to_s", "String", "Opal", "coerce_to!", "Integer", "check", "check_until", "peek", "length", "eos?", "exist?", "skip", "skip_until", "get_byte", "match?", "pos=", "pos", "matched_size", "post_match", "pre_match", "reset", "rest", "rest?", "rest_size", "size", "terminate", "unscan", "private"], :mappings=>"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"}}, {:offset=>{:line=>1211, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/normalize.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nmodule BCDice\n  module Normalize\n    module_function\n\n    # 比較演算子をシンボルに正規化する\n    #\n    # @param op [String]\n    # @return [Symbol, nil]\n    def comparison_operator(op)\n      case op\n      when /<=|=</\n        :<=\n      when />=|=>/\n        :>=\n      when /<>|!=|=!/\n        :'!='\n      when /</\n        :<\n      when />/\n        :>\n      when /=/\n        :==\n      end\n    end\n\n    # 目標値を正規化する\n    #\n    # @param val [String]\n    # @return [Integer, String] 整数か'?'\n    def target_number(val)\n      if val == \"?\"\n        val\n      else\n        val.to_i\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "<module:BCDice>", "<module:Normalize>", "self", "module_function", "comparison_operator", "op", "$ret_or_1", "target_number", "val", "to_i"], :mappings=>"AAAAA,mCAAAA,gBAAAA;EAAAA;;EAEAA,OAAAC;EAAAA;;IAAAA;;IACEA,OAAAC;IAAAA;;;;MACEC,IAAAC,iBAAAA,CAAAA;;AAMAC,MAAAA,mCAAAA,+BAAwBC,EAAxBD;AAAAA,QAAAA;;QAEE,IAAA,QAAK,OAAL,EADAE,CAAAA,YAAKD,EAALC,CACA,CAAA;UACEF,OAAA;QADF,OAEA,IAAA,QAAK,OAAL,EAdN,SAcM,CAAA;UACEA,OAAA;QADF,OAEA,IAAA,QAAK,UAAL,EAhBN,SAgBM,CAAA;UACEA,OAAA;QADF,OAEA,IAAA,QAAK,GAAL,EAlBN,SAkBM,CAAA;UACEA,OAAA;QADF,OAEA,IAAA,QAAK,GAAL,EApBN,SAoBM,CAAA;UACEA,OAAA;QADF,OAEA,IAAA,QAAK,GAAL,EAtBN,SAsBM,CAAA;UACEA,OAAA;QADF;UAXAA,OAAA;QAWA;MAZFA,CAAAA;MAqBAH,OAAAM,6BAAAA,yBAAkBC,GAAlBD;AAAAA;QACE,IAAA,MAAGC,GAAH,EAAUD,GAAV,CAAA;UACEA,OAAAC;QADF;UAGED,OAAAC,GAAGC,MAAAA,CAAAA;QAHL;MADFF,CAAAA;IA5BFN,GAAAA,WAAAA;EADFD,GAAAA,WAAAA;AAFAD;"}}, {:offset=>{:line=>1257, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/common_command/lexer.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nrequire \"strscan\"\nrequire \"bcdice/normalize\"\n\nmodule BCDice\n  module CommonCommand\n    class Lexer\n      SYMBOLS = {\n        \"+\" => :PLUS,\n        \"-\" => :MINUS,\n        \"*\" => :ASTERISK,\n        \"/\" => :SLASH,\n        \"(\" => :PARENL,\n        \")\" => :PARENR,\n        \"[\" => :BRACKETL,\n        \"]\" => :BRACKETR,\n        \"?\" => :QUESTION,\n        \"@\" => :AT,\n      }.freeze\n\n      def initialize(source)\n        # sourceが空文字だとString#splitが空になる\n        source = source.split(\" \", 2).first || \"\"\n        @scanner = StringScanner.new(source)\n      end\n\n      def next_token\n        return [false, \"$\"] if @scanner.eos?\n\n        if (number = @scanner.scan(/\\d+/))\n          [:NUMBER, number.to_i]\n        elsif (cmp_op = @scanner.scan(/[<>!=]+/))\n          [:CMP_OP, Normalize.comparison_operator(cmp_op)]\n        else\n          char = @scanner.getch.upcase\n          type = SYMBOLS[char] || char.to_sym\n          [type, char]\n        end\n      end\n\n      def source\n        @scanner.string\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "self", "require", "<module:BCDice>", "<module:CommonCommand>", "<class:Lexer>", "freeze", "initialize", "source", "$ret_or_1", "split", "2", "first", "@scanner", "StringScanner", "new", "next_token", "eos?", "number", "scan", "to_i", "cmp_op", "Normalize", "comparison_operator", "char$", "getch", "upcase", "type", "SYMBOLS", "[]", "to_sym", "string"], :mappings=>"AAAAA,8CAAAA,gBAAAA;EAAAA;;;EAEAC,IAAAC,SAAAA,CAAQF,SAARE;EACAD,IAAAC,SAAAA,CAAQF,kBAARE;EAEAF,OAAAG;EAAAA;;IAAAA;;IACEA,OAAAC;IAAAA;;MAAAA;;MACEA,OAAAC;MAAAA;;QAAAA;;AAAAA;;QACE,mCAAU,4DAAA,KACD,MADC,EAAA,KAED,OAFC,EAAA,KAGD,UAHC,EAAA,KAID,OAJC,EAAA,KAKD,QALC,EAAA,KAMD,QANC,EAAA,KAOD,UAPC,EAAA,KAQD,UARC,EAAA,KASD,UATC,EAAA,KAUD,IAVC,EAWTC,QAAAA,CAAAA,CAXD;;AAaAC,QAAAA,0BAAAA,sBAAeC,MAAfD;AAAAA,UAAAA;;;UAEEC,SAAS,CAAA,QAAAC,CAAAA,YAAAD,MAAME,OAAAA,CAAOH,GAAb,EAAkBI,CAAZD,CAAcE,OAAAA,CAAAA,CAApBH,CAAA,CAAA,GAAA,CAAA,SAAA,IAAA,CAA8BF,EAA9B,CAAA;UACTA,OAAAM,CAAAA,eAAWC,mBAAaC,KAAAA,CAAKP,MAALO,CAAxBF;QAHFN,CAAAA;;AAMAS,QAAAA,0BAAAA,sBAAAA;AAAAA,UAAAA;;;UACE,IAAA,QAAuBH,YAAQI,SAAAA,CAAAA,CAA/B,CAAA;YAAA,OAAO,CAAC,KAAD,EAAQD,GAAR;UAAP;UAEA,IAAA,QAAIE,CAAAA,SAASL,YAAQM,MAAAA,CAAM,KAANA,CAAjBD,CAAJ,CAAA;YACEF,OAAA,CAAC,QAAD,EAAUE,MAAME,MAAAA,CAAAA,CAAhB;UADF,OAEA,IAAA,QAAOC,CAAAA,SAASR,YAAQM,MAAAA,CAAM,SAANA,CAAjBE,CAAP,CAAA;YACEL,OAAA,CAAC,QAAD,EAAUM,eAASC,qBAAAA,CAAqBF,MAArBE,CAAnB;UADF;;YAGEC,QAAOX,YAAQY,OAAAA,CAAAA,CAAMC,QAAAA,CAAAA;YACrBC,OAAO,CAAA,QAAAlB,CAAAA,YAAAmB,aAAOC,OAAAA,CAACL,KAADK,CAAPpB,CAAA,CAAA,GAAA,CAAA,SAAA,IAAA,CAAiBe,KAAIM,QAAAA,CAAAA,CAArB,CAAA;YACPd,OAAA,CAACW,IAAD,EAAOH,KAAP;UALF;QALFR,CAAAA;QAcAX,OAAAG,sBAAAA,kBAAAA;AAAAA,UAAAA;;UACEA,OAAAK,YAAQkB,QAAAA,CAAAA;QADVvB,CAAAA;MAlCFH,GAAAA,WAAAA,EAAAA,IAAAA;IADFD,GAAAA,WAAAA;EADFD,GAAAA,WAAAA;AALAH;"}}, {:offset=>{:line=>1318, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/arithmetic/parser.rb"], :sourcesContent=>["#\n# DO NOT MODIFY!!!!\n# This file is automatically generated by Racc 1.7.3\n# from Racc grammar file \"parser.y\".\n#\n\nrequire 'racc/parser.rb'\n\n\nrequire \"bcdice/common_command/lexer\"\nrequire \"bcdice/arithmetic/node\"\n\nmodule BCDice\n  module Arithmetic\n    class Parser < Racc::Parser\n\n\ndef self.parse(source)\n  new.parse(source)\nend\n\ndef parse(source)\n  @lexer = BCDice::CommonCommand::Lexer.new(source)\n  do_parse()\nrescue ParseError\n  nil\nend\n\nprivate\n\ndef next_token\n  @lexer.next_token\nend\n##### State transition tables begin ###\n\nracc_action_table = [\n     8,    17,     8,    12,    13,     4,     5,     4,     5,     7,\n     8,     7,     8,    12,    13,     4,     5,     4,     5,     7,\n     8,     7,     8,    12,    13,     4,     5,     4,     5,     7,\n     8,     7,     8,   nil,   nil,     4,     5,     4,     5,     7,\n     9,     7,   nil,   nil,    10,    11,   nil,    10,    11,    22,\n    26,    24,    25,    27 ]\n\nracc_action_check = [\n     0,     9,     4,     2,     2,     0,     0,     4,     4,     0,\n     5,     4,     7,    18,    18,     5,     5,     7,     7,     5,\n    10,     7,    11,    19,    19,    10,    10,    11,    11,    10,\n    12,    11,    13,   nil,   nil,    12,    12,    13,    13,    12,\n     1,    13,   nil,   nil,    16,    16,   nil,     1,     1,    16,\n    21,    21,    21,    21 ]\n\nracc_action_pointer = [\n    -2,    40,    -6,   nil,     0,     8,   nil,    10,   nil,     1,\n    18,    20,    28,    30,   nil,   nil,    37,   nil,     4,    14,\n   nil,    47,   nil,   nil,   nil,   nil,   nil,   nil ]\n\nracc_action_default = [\n   -17,   -17,    -3,    -6,   -17,   -17,   -14,   -17,   -16,   -17,\n   -17,   -17,   -17,   -17,   -12,   -13,   -17,    28,    -1,    -2,\n    -4,    -7,   -15,    -5,    -8,    -9,   -10,   -11 ]\n\nracc_goto_table = [\n    14,    15,    23,     1,    18,    19,   nil,   nil,    20,    21,\n    16 ]\n\nracc_goto_check = [\n     3,     3,     4,     1,     2,     2,   nil,   nil,     3,     3,\n     1 ]\n\nracc_goto_pointer = [\n   nil,     3,    -6,    -4,   -19,   nil ]\n\nracc_goto_default = [\n   nil,   nil,     2,     3,   nil,     6 ]\n\nracc_reduce_table = [\n  0, 0, :racc_error,\n  3, 14, :_reduce_1,\n  3, 14, :_reduce_2,\n  1, 14, :_reduce_none,\n  3, 15, :_reduce_4,\n  4, 15, :_reduce_5,\n  1, 15, :_reduce_none,\n  0, 17, :_reduce_7,\n  1, 17, :_reduce_8,\n  1, 17, :_reduce_9,\n  1, 17, :_reduce_10,\n  1, 17, :_reduce_11,\n  2, 16, :_reduce_12,\n  2, 16, :_reduce_13,\n  1, 16, :_reduce_none,\n  3, 18, :_reduce_15,\n  1, 18, :_reduce_16 ]\n\nracc_reduce_n = 17\n\nracc_shift_n = 28\n\nracc_token_table = {\n  false => 0,\n  :error => 1,\n  :NUMBER => 2,\n  :R => 3,\n  :U => 4,\n  :C => 5,\n  :F => 6,\n  :PLUS => 7,\n  :MINUS => 8,\n  :ASTERISK => 9,\n  :SLASH => 10,\n  :PARENL => 11,\n  :PARENR => 12 }\n\nracc_nt_base = 13\n\nracc_use_result_var = true\n\nRacc_arg = [\n  racc_action_table,\n  racc_action_check,\n  racc_action_default,\n  racc_action_pointer,\n  racc_goto_table,\n  racc_goto_check,\n  racc_goto_default,\n  racc_goto_pointer,\n  racc_nt_base,\n  racc_reduce_table,\n  racc_token_table,\n  racc_shift_n,\n  racc_reduce_n,\n  racc_use_result_var ]\nRactor.make_shareable(Racc_arg) if defined?(Ractor)\n\nRacc_token_to_s_table = [\n  \"$end\",\n  \"error\",\n  \"NUMBER\",\n  \"R\",\n  \"U\",\n  \"C\",\n  \"F\",\n  \"PLUS\",\n  \"MINUS\",\n  \"ASTERISK\",\n  \"SLASH\",\n  \"PARENL\",\n  \"PARENR\",\n  \"$start\",\n  \"add\",\n  \"mul\",\n  \"unary\",\n  \"round_type\",\n  \"term\" ]\nRactor.make_shareable(Racc_token_to_s_table) if defined?(Ractor)\n\nRacc_debug_parser = false\n\n##### State transition tables end #####\n\n# reduce 0 omitted\n\ndef _reduce_1(val, _values, result)\n result = Arithmetic::Node::BinaryOp.new(val[0], :+, val[2])\n    result\nend\n\ndef _reduce_2(val, _values, result)\n result = Arithmetic::Node::BinaryOp.new(val[0], :-, val[2])\n    result\nend\n\n# reduce 3 omitted\n\ndef _reduce_4(val, _values, result)\n result = Arithmetic::Node::BinaryOp.new(val[0], :*, val[2])\n    result\nend\n\ndef _reduce_5(val, _values, result)\n         divied_class = val[3]\n         result = divied_class.new(val[0], val[2])\n\n    result\nend\n\n# reduce 6 omitted\n\ndef _reduce_7(val, _values, result)\n result = Arithmetic::Node::DivideWithGameSystemDefault\n    result\nend\n\ndef _reduce_8(val, _values, result)\n result = Arithmetic::Node::DivideWithCeil\n    result\nend\n\ndef _reduce_9(val, _values, result)\n result = Arithmetic::Node::DivideWithCeil\n    result\nend\n\ndef _reduce_10(val, _values, result)\n result = Arithmetic::Node::DivideWithRound\n    result\nend\n\ndef _reduce_11(val, _values, result)\n result = Arithmetic::Node::DivideWithFloor\n    result\nend\n\ndef _reduce_12(val, _values, result)\n result = val[1]\n    result\nend\n\ndef _reduce_13(val, _values, result)\n result = Arithmetic::Node::Negative.new(val[1])\n    result\nend\n\n# reduce 14 omitted\n\ndef _reduce_15(val, _values, result)\n result = val[1]\n    result\nend\n\ndef _reduce_16(val, _values, result)\n result = Arithmetic::Node::Number.new(val[0])\n    result\nend\n\ndef _reduce_none(val, _values, result)\n  val[0]\nend\n\n    end   # class Parser\n  end   # module Arithmetic\nend   # module BCDice\n"], :names=>["<top (required)>", "self", "require", "<module:BCDice>", "<module:Arithmetic>", "<class:Parser>", "parse", "source", "new", "@lexer", "BCDice::CommonCommand::Lexer", "BCDice::CommonCommand", "BCDice", "do_parse", "ParseError", "private", "next_token", "racc_action_table", "racc_action_check", "racc_action_pointer", "-2", "40", "-6", "0", "8", "10", "1", "18", "20", "28", "30", "37", "4", "14", "47", "racc_action_default", "-17", "-3", "-14", "-16", "-12", "-13", "-1", "-4", "-7", "-15", "-5", "-8", "-9", "-10", "-11", "racc_goto_table", "15", "23", "19", "21", "16", "racc_goto_check", "3", "2", "racc_goto_pointer", "-19", "racc_goto_default", "6", "racc_reduce_table", "racc_reduce_n", "17", "racc_shift_n", "racc_token_table", "5", "7", "9", "11", "12", "racc_nt_base", "13", "racc_use_result_var", "Ractor", "make_shareable", "Racc_arg", "Racc_token_to_s_table", "_reduce_1", "val", "_values", "result", "Arithmetic::Node::BinaryOp", "Arithmetic::Node", "Arithmetic", "[]", "_reduce_2", "_reduce_4", "_reduce_5", "divied_class", "_reduce_7", "Arithmetic::Node::DivideWithGameSystemDefault", "_reduce_8", "Arithmetic::Node::DivideWithCeil", "_reduce_9", "_reduce_10", "Arithmetic::Node::DivideWithRound", "_reduce_11", "Arithmetic::Node::DivideWithFloor", "_reduce_12", "_reduce_13", "Arithmetic::Node::Negative", "_reduce_15", "_reduce_16", "Arithmetic::Node::Number", "_reduce_none", "Racc::Parser", "Racc"], :mappings=>"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"}}, {:offset=>{:line=>1470, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/arithmetic.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nrequire \"bcdice/arithmetic/node\"\nrequire \"bcdice/arithmetic/parser\"\n\nmodule BCDice\n  module Arithmetic\n    class << self\n      # 四則演算を評価する\n      #\n      # @param source [String]\n      # @param round_type [Symbol]\n      # @return [Integer, nil] パースできない式やゼロ除算が発生した場合にはnilを返す\n      def eval(source, round_type)\n        node = Parser.parse(source)\n        node&.eval(round_type)\n      rescue ZeroDivisionError\n        nil\n      end\n    end\n  end\nend\n"], :names=>["<top (required)>", "self", "require", "<module:BCDice>", "<module:Arithmetic>", "eval", "source", "round_type", "node", "Parser", "parse", "ZeroDivisionError"], :mappings=>"AAAAA,oCAAAA,gBAAAA;EAAAA;;;EAEAC,IAAAC,SAAAA,CAAQF,wBAARE;EACAD,IAAAC,SAAAA,CAAQF,0BAARE;EAEAF,OAAAG;EAAAA;;IAAAA;;IACEA,OAAAC;IAAAA;;MAAAA;;MACEA,OAAA;QAAA;;QAME,OAAAC,oBAAAA,iBAASC,MAAD,EAASC,UAAjBF,GAAAA,MAAAA,IAAAA,wCAAAA;AAAAA,UAAAA;;UACE;;YAAAG,OAAOC,YAAMC,OAAAA,CAAOJ,MAAPI;YACbL,OAAA,CAAA,KAAAG,IAAA,qCAAA,EAAA,MAAA,CAAWD,UAAX,CAAA;UADA;YAEF,sBAAO,CAAAI,uBAAA,CAAP;cAAA;gBACEN,OAAA;cADF;YAAA,CAFE;UAAA,CADFA;YAAAA;YAAAA;UAAAA;QAAAA,CAAAA;MANF,4BAASJ,IAAT;IADFG,GAAAA,WAAAA;EADFD,GAAAA,WAAAA;AALAH;"}}, {:offset=>{:line=>1512, :column=>0}, :map=>{:version=>3, :sourceRoot=>"", :sources=>["bcdice/game_system/AngelGear.rb"], :sourcesContent=>["# frozen_string_literal: true\n\nrequire \"bcdice/dice_table/table\"\nrequire \"bcdice/dice_table/d66_grid_table\"\nrequire \"bcdice/arithmetic\"\n\nmodule BCDice\n  module GameSystem\n    class AngelGear < Base\n      # ゲームシステムの識別子\n      ID = 'AngelGear'\n\n      # ゲームシステム名\n      NAME = 'エンゼルギア 天使大戦TRPG The 2nd Editon'\n\n      # ゲームシステム名の読みがな\n      SORT_KEY = 'えんせるきあ2'\n\n      # ダイスボットの使い方\n      HELP_MESSAGE = <<~MESSAGETEXT\n        ・判定　nAG[s][±a]\n        []内は省略可能。\n        n:判定値\n        s:技能値\n        a:修正\n        （例）\n        12AG 10AG3±20\n\n        ・感情表　ET\n      MESSAGETEXT\n\n      def initialize(command)\n        super(command)\n\n        @sort_barabara_dice = true # バラバラロール（Bコマンド）でソート有\n      end\n\n      def eval_game_system_specific_command(command)\n        if (m = /^(\\d+)AG(\\d+)?(([+-]\\d+)*)$/.match(command))\n          resolute_action(m[1].to_i, m[2]&.to_i, m[3], command)\n        else\n          roll_tables(command, TABLES)\n        end\n      end\n\n      def resolute_action(num_dice, skill_value, modify, command)\n        dice = @randomizer.roll_barabara(num_dice, 6).sort\n        dice_text = dice.join(\",\")\n        modify_n = 0\n        success = 0\n        if skill_value\n          success = dice.count { |val| val <= skill_value }\n          modify_n = Arithmetic.eval(modify, RoundType::FLOOR) unless modify.empty?\n        end\n\n        gospel = '(福音発生)' if success + modify_n >= 100\n\n        output = \"(\#{command}) ＞ \#{success}[\#{dice_text}]\#{format('%+d', modify_n)} ＞ 成功数: \#{success + modify_n}\#{gospel}\"\n\n        if success + modify_n >= 100\n          Result.critical(output)\n        elsif 0 < success + modify_n\n          Result.success(output)\n        else\n          Result.failure(output)\n        end\n      end\n\n      TABLES = {\n        'ET' => DiceTable::D66GridTable.new(\n          '感情表',\n          [\n            [\n              '好奇心（好奇心）',\n              '憧れ（あこがれ）',\n              '尊敬（そんけい）',\n              '仲間意識（なかまいしき）',\n              '母性愛（ぼせいあい）',\n              '感心（かんしん）'\n            ],\n            [\n              '純愛（じゅんあい）',\n              '友情（ゆうじょう）',\n              '同情（どうじょう）',\n              '父性愛（ふせいあい）',\n              '幸福感（こうふくかん）',\n              '信頼（しんらい）'\n            ],\n            [\n              '競争心（きょうそうしん）',\n              '親近感（しんきんかん）',\n              'まごころ',\n              '好意（こうい）',\n              '有為（ゆうい）',\n              '崇拝（すうはい）'\n            ],\n            [\n              '大嫌い（だいきらい）',\n              '妬み（ねたみ）',\n              '侮蔑（ぶべつ）',\n              '腐れ縁（くされえん）',\n              '恐怖（きょうふ）',\n              '劣等感（れっとうかん）'\n            ],\n            [\n              '偏愛（へんあい）',\n              '寂しさ（さびしさ）',\n              '憐憫（れんびん）',\n              '闘争心（とうそうしん）',\n              '食傷（しょくしょう）',\n              '嘘つき（うそつき）'\n            ],\n            [\n              '甘え（あまえ）',\n              '苛立ち（いらだち）',\n              '下心（したごころ）',\n              '憎悪（ぞうお）',\n              '疑惑（ぎわく）',\n              '支配（しはい）'\n            ],\n          ]\n        )\n      }.freeze\n\n      register_prefix('\\d+AG', TABLES.keys)\n    end\n  end\nend\n"], :names=>["<main>", "self", "require", "<module:BCDice>", "<module:GameSystem>", "<class:AngelGear>", "initialize", "command", "@sort_barabara_dice", "eval_game_system_specific_command", "m", "match", "resolute_action", "[]", "1", "to_i", "2", "3", "roll_tables", "TABLES", "num_dice", "skill_value", "modify", "dice", "@randomizer", "roll_barabara", "6", "sort", "dice_text", "join", "modify_n", "0", "success", "count", "block in resolute_action", "val", "block (2 levels) in resolute_action", "<=", "empty?", "Arithmetic", "eval", "RoundType::FLOOR", "RoundType", ">=", "+", "100", "gospel", "output", "format", "Result", "critical", "<", "failure", "DiceTable::D66GridTable", "DiceTable", "new", "freeze", "register_prefix", "keys", "Base"], :mappings=>"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"}}]}